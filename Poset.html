<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Poset â€” fixed regions + coloring buttons</title>

  <script src="https://unpkg.com/cytoscape/dist/cytoscape.min.js"></script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <style>
    html,body { height:100%; margin:0; }
    body {
      display: flex;
      height: 100vh;
      margin: 0;
      font-family: sans-serif;
      overflow: hidden;
    }

    /* main (graph) area */
    #main {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      min-width: 0; /* important so legend doesn't get pushed off */
    }

    #controls {
      padding: 6px;
      border-bottom: 1px solid #ddd;
      background: #fafafa;
    }

    #cy-container {
      position: relative;
      flex: 1 1 auto;
      min-width: 0;
      overflow: hidden;
    }

    /* Cytoscape canvas */
    #cy {
      width: 100%;
      height: 100%;
      position: relative;
      z-index: 1;    /* base graph */
      box-sizing: border-box;
    }

    /* SVG regions: above the cytoscape canvas, below labels */
    #regions {
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      z-index: 2;
      pointer-events: none; /* let clicks through */
    }

    /* floating LaTeX labels */
    .label {
      position: absolute;
      pointer-events: none;
      transform: translate(-50%, -50%);
      white-space: nowrap;
      font-family: serif;
      z-index: 3;  /* always on top */
    }

    /* legend fixed on the right */
    #legend {
      flex: 0 0 450px; /* fixed width */
      border-left: 1px solid #ccc;
      padding: 12px;
      box-sizing: border-box;
      overflow-y: auto;
      background: #fff;
    }
    .legend-item { display:flex; align-items:center; margin-bottom:8px; }
    .legend-color { width:20px; height:20px; margin-right:8px; border:1px solid rgba(0,0,0,0.2); }
    button { margin-right:6px; }
  </style>
</head>
<body>

  <div id="main">
    <div id="controls">
      <button id="btnToggleLabels">Switch to Clones</button>
      <button id="btnToggleRegions">Hide Complexity Classes</button>
      <label for="colorSelect">Choose H1 condition:</label>
<select id="colorSelect">
  <option value="none">None</option>
  <option value="majority">Majority</option>
  <option value="nu4">NU(4)</option>
  <option value="nu5">NU(5)</option>
  <option value="maltsev">Maltsev</option>
  <option value="hm2">HM(2)</option>
</select>
    </div>

    <div id="cy-container">
      <div id="cy"></div>
      <!-- SVG is after #cy so it can be layered above it -->
      <svg id="regions" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg"></svg>
    </div>
  </div>

<div id="legend">
  <div style="display: flex; flex-direction: column;">
    <div id="region-legend">
      <h3>Regions</h3>
      <div class="legend-item">
        <div class="legend-color" style="background-color: rgba(75, 192, 192, 0.2); border:1px solid green"></div>
        L
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background-color: rgba(54, 162, 235, 0.2); border:1px solid blue"></div>
        NL Complete
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background-color: rgba(153, 102, 255, 0.2); border:1px solid purple"></div>
        Mod2L Complete
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background-color: rgba(255, 159, 64, 0.2); border:1px solid orange"></div>
        P Complete
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background-color: rgba(255, 99, 71, 0.2); border:1px solid red"></div>
        NP Complete
      </div>
    </div>

    <div id="colorset-legend" style="margin-top:16px; display:none;">
      <h3>H1 Condition</h3>
      <span id="colorset-legend-text"></span>
    </div>

    <div id="label-legend">
      <h3>Labels</h3>
      <div id="label-legend-items"></div>
    </div>
  </div>
</div>


  <script>
    // --------------------------
    // Data (nodes, edges, labels, regions)
    // --------------------------
    const s = 1.2;
    const nodes = [
      { data: { id: 'C1' }, position: { x: 300*s, y: 50*s } },
      { data: { id: 'I2' }, position: { x: 300*s, y: 100*s } },
      { data: { id: 'B2' }, position: { x: 335*s, y: 135*s } },
      { data: { id: 'B3' }, position: { x: 370*s, y: 170*s } },
      { data: { id: 'B4' }, position: { x: 400*s, y: 200*s } },
      { data: { id: 'Binf' }, position: { x: 450*s, y: 250*s } },
      { data: { id: 'Bleq' }, position: { x: 300*s, y: 170*s } },
      { data: { id: 'Bleq3' }, position: { x: 335*s, y: 205*s } },
      { data: { id: 'Bleq4' }, position: { x: 365*s, y: 235*s } },
      { data: { id: 'Bleqinf' }, position: { x: 415*s, y: 285*s } },
      { data: { id: 'C2' }, position: { x: 185*s, y: 215*s } },
      { data: { id: 'Cleq2' }, position: { x: 220*s, y: 250*s } },
      { data: { id: 'LIN' }, position: { x: 150*s, y: 250*s } },
      { data: { id: 'HORN' }, position: { x: 350*s, y: 350*s } },
      { data: { id: 'NAE' }, position: { x: 300*s, y: 400*s } },
      { data: { id: 'HL1' }, position: { x: 300*s, y: 20*s }, classes:'helper' },
      { data: { id: 'HL2' }, position: { x: 150*s, y: 215*s }, classes:'helper' },
      { data: { id: 'HL3' }, position: { x: 185*s, y: 250*s }, classes:'helper' },
      { data: { id: 'HL4' }, position: { x: 300*s, y: 135*s }, classes:'helper' },
      { data: { id: 'HL5' }, position: { x: 450*s, y: 285*s }, classes:'helper' },
      { data: { id: 'HL6' }, position: { x: 485*s, y: 250*s }, classes:'helper' },
      { data: { id: 'HNL1' }, position: { x: 255*s, y: 320*s }, classes:'helper' },
      { data: { id: 'HNL2' }, position: { x: 415*s, y: 320*s }, classes:'helper' },
      { data: { id: 'HLin1' }, position: { x: 115*s, y: 250*s }, classes:'helper' },
      { data: { id: 'HLin2' }, position: { x: 185*s, y: 320*s }, classes:'helper' },
      { data: { id: 'HNP1' }, position: { x: 300*s, y: 435*s }, classes:'helper' },
      { data: { id: 'HNP2' }, position: { x: 355*s, y: 380*s }, classes:'helper' },
      { data: { id: 'HNP3' }, position: { x: 245*s, y: 380*s }, classes:'helper' },
  
    ];

    const edges = [
      { data: { source: 'C1', target: 'I2' } },
      { data: { source: 'I2', target: 'B2' }},
      { data: { source: 'I2', target: 'C2' } },
      { data: { source: 'Bleq', target: 'Bleq3' } },
      { data: { source: 'Bleq', target: 'B2' } },
      { data: { source: 'Bleq3', target: 'B3' } },
      { data: { source: 'Bleq4', target: 'B4' } },
      { data: { source: 'Bleq3', target: 'Bleq4' } },
      { data: { source: 'B2', target: 'B3' } },
      { data: { source: 'B3', target: 'B4' } },
      { data: { source: 'B4', target: 'Binf' },classes: 'dashed' },
      { data: { source: 'Bleq4', target: 'Bleqinf' },classes: 'dashed' },
      { data: { source: 'Bleqinf', target: 'Binf' } },
      { data: { source: 'Bleqinf', target: 'HORN' } },
      { data: { source: 'C2', target: 'LIN' } },
      { data: { source: 'LIN', target: 'NAE' } },
      { data: { source: 'Cleq2', target: 'Bleq' } },
      { data: { source: 'C2', target: 'Cleq2' } },
      { data: { source: 'Cleq2', target: 'NAE' } },
      { data: { source: 'NAE', target: 'HORN' } }
    ];

    // Label sets (latex strings)
    const labelSets = {
      Structures: {
        C1: "\\(\\mathbb C_1\\)", I2: "\\(\\mathbb I_2\\)", B2: "\\(\\mathbb B_2\\)", B3: "\\(\\mathbb B_3\\)", B4: "\\(\\mathbb B_4\\)",
        Binf: "\\(\\mathbb B_\\infty\\)", Bleq: "\\(\\text{st-Con}\\)", Bleq3: "\\(\\mathbb B_{3}^{\\leq}\\)",
        Bleq4: "\\(\\mathbb B_{4}^{\\leq}\\)", Bleqinf: "\\(\\mathbb B_{\\infty}^{\\leq}\\)", C2: "\\(\\mathbb C_2\\)",
        Cleq2: "\\(2\\mathbb S\\text{AT}\\)", LIN: "\\(3\\mathbb L\\text{IN}_2\\)", HORN: "\\(\\mathbb H\\text{ORN}\\)",
        NAE: "\\(1\\text{IN}3\\)"
      },
      Clones: {
        C1: "\\([0]\\)", I2: "\\([m,q]\\)", B2: "\\([d_3,q]\\)", B3: "\\([d_4,q]\\)",
        B4: "\\([d_5,q]\\)", Binf: "\\([q]\\)", Bleq: "\\([d_3,p]\\)",
        Bleq3: "\\([d_4]\\)", Bleq4: "\\([d_5]\\)",
        Bleqinf: "\\([p]\\)", C2: "\\([d_3,m]\\)",
        Cleq2: "\\([d_3]\\)", LIN: "\\([m]\\)",
        HORN: "\\([\\wedge]\\)", NAE: "\\([\\emptyset]\\)"
      }
    };

        // Label sets (latex strings)
    const legendLabelSets = {
      Structures: {
        C1: "\\(\\mathbb C_1=(\\{0\\},\\{(0,0)\\})\\)", 
        I2: "\\(\\mathbb I_2=(\\{0,1\\},\\{(0,1)\\})\\)", 
        B2: "\\(\\mathbb B_2=(\\{0,1\\},\\{0\\},\\{0,1\\}^2\\setminus\\{(0,0)\\})\\)", 
        B3: "\\(\\mathbb B_3=(\\{0,1\\},\\{0\\},\\{0,1\\}^3\\setminus\\{(0,0,0)\\})\\)", 
        B4: "\\(\\mathbb B_4=(\\{0,1\\},\\{0\\},\\{0,1\\}^4\\setminus\\{(0,0,0,0)\\})\\)",
        Binf: "\\(\\mathbb B_\\infty=(\\{0,1\\},\\{0\\},\\{0,1\\}^n\\setminus\\{(0,\\dots,0)\\}\\colon n\\geq 2)\\)", 
        Bleq: "\\(\\text{st-Con}=(\\{0,1\\},\\{0\\},\\{1\\},\\leq)\\)", 
        Bleq3: "\\(\\mathbb B_{3}^{\\leq}=(\\mathbb B_3,\\leq)\\)",
        Bleq4: "\\(\\mathbb B_{4}^{\\leq}=(\\mathbb B_4,\\leq)\\)", 
        Bleqinf: "\\(\\mathbb B_{\\infty}^{\\leq}=(\\mathbb B_{\\infty},\\leq)\\)", 
        C2: "\\(\\mathbb C_2=(\\{0,1\\},\\neq)\\)",
        Cleq2: "\\(2\\mathbb S\\text{AT}=(\\{0,1\\},\\{0\\}\\neq,\\leq)\\)", 
        LIN: "\\(3\\mathbb L\\text{IN}_2=(\\{0,1\\},\\{0\\},x+y+z=1)\\)", 
        HORN: "\\(\\mathbb H\\text{ORN}=(\\{0,1\\},\\{0\\},\\{1\\},(x\\wedge y)\\Rightarrow z)\\)",
        NAE: "\\(1\\text{IN}3=(\\{0,1\\},\\{(0,0,1),(0,1,0),(1,0,0)\\})\\)"
      },
      Clones: {
        O : "\\(0(x)=0\\)",
        m: "\\(m(x,y,z)=x\\oplus y\\oplus z\\)",
        q: "\\(q(x,y,z)=x\\wedge (y\\Leftrightarrow z)\\)",
        d3: "\\(d_3=\\text{the unique majority on }\\{0,1\\}\\)",
        dn: "\\(d_n(x_1,\\dots,x_n)=\\bigvee_{i=1}^n\\bigwedge_{j\\neq i} x_j\\)",
        //dn: "\\(d_n(x_1,\\dots,x_n)=\\bigvee_{i=1}^n(x_1\\wedge\\dots\\wedge x_{i-1}\\wedge x_{i+1}\\wedge\\dots\\wedge x_n))\\)",
        p: "\\(p(x,y,z)=x\\wedge (y\\vee z)\\)"
      }
    };
    let currentSet = 'Structures';

    // Regions: you can edit these polygons (pixel coordinates relative to the cy container)
    // Make sure coordinates are in the same coordinate system as the cy container (pixels).
    const regionDefs = [
  { 
    color: 'rgba(75, 192, 192, 0.2)', border: 'green',
    nodes: ['HL1','HL2','HL3','HL4','HL5','HL6']  // region bound by these nodes
  },
  { 
    color: 'rgba(54, 162, 235, 0.2)', border: 'blue',
    nodes: ['HNL1', 'HNL2','HL5','HL4','HL3']
  },
  { 
    color: 'rgba(153, 102, 255, 0.2)', border: 'purple',
    nodes: ['HLin1', 'HLin2','HNL1','HL2']
  },
  { 
    color: 'rgba(255, 159, 64, 0.2)', border: 'orange',
    nodes: ['HLin2', 'HNL2','HNP2','HNP3']
  },
  { 
    color: 'rgba(255, 99, 71, 0.2)', border: 'red',
    nodes: ['HNP1','HNP2','HNP3']
  }
];
    let regionsVisible = true; // declared before functions so no TDZ

    // --------------------------
    // Init Cytoscape
    // --------------------------
    const cy = cytoscape({
      container: document.getElementById('cy'),
      elements: { nodes: nodes, edges: edges },
      layout: { name: 'preset' },
      style: [
        { selector: 'node', style: { 'background-color': '#0074D9', 'width': 20, 'height': 20 } },
        { selector: 'edge', style: { 'curve-style': 'bezier', 'width': 2, 'line-color': '#878686' } }, // undirected
        { selector: 'edge.dashed', style: { 'line-style': 'dashed' } },
        { selector: 'node.helper', style: { 
      'background-opacity': 0,
      'width': 0,
      'height': 0,
      'label': ''
    } }
      ],
      userZoomingEnabled: false,
      userPanningEnabled: false,
      boxSelectionEnabled: false,
    });

    // lock nodes so they are static
    cy.nodes().forEach(n => n.lock());

    // --------------------------
    // HTML labels (MathJax-friendly)
    // --------------------------
    const cyContainer = document.getElementById('cy-container');
    const labels = {};

    nodes.forEach(n => {
      const div = document.createElement('div');
      div.className = 'label';
      div.style.zIndex = 3;
      const id = n.data.id;
      div.innerHTML = labelSets[currentSet][id] || id;
      cyContainer.appendChild(div);
      labels[id] = div;
    });

function updateLabelPositions() {
  cy.nodes().forEach(n => {
    // skip helper nodes
    if (n.hasClass('helper')) return;

    const pos = n.renderedPosition();
    const div = labels[n.id()];
    if (!div) return;
    div.style.left = pos.x + 'px';
    div.style.top = (pos.y - 0) + 'px'; // a little above the node
    div.style.display = 'block'; // make sure it's visible
  });

  // typeset the labels that may contain LaTeX
  if (window.MathJax && MathJax.typesetPromise) {
    MathJax.typesetPromise().catch(err => console.warn('MathJax error:', err));
  }
}


    cy.on('render', updateLabelPositions);

    // initial label placement
    updateLabelPositions();

    // --------------------------
    // SVG regions: sizing + drawing
    // --------------------------
    const regionsSVG = document.getElementById('regions');

    function syncSVGSize() {
      const rect = cy.container().getBoundingClientRect();
      const w = Math.max(1, Math.round(rect.width));
      const h = Math.max(1, Math.round(rect.height));
      regionsSVG.setAttribute('width', w);
      regionsSVG.setAttribute('height', h);
      regionsSVG.setAttribute('viewBox', `0 0 ${w} ${h}`);
    }

function pointsToSmoothPath(points, tension = 0.3) {
  if (points.length < 2) return '';
  let path = `M ${points[0][0]} ${points[0][1]}`;
  for (let i = 0; i < points.length; i++) {
    const p0 = points[i === 0 ? points.length - 1 : i - 1];
    const p1 = points[i];
    const p2 = points[(i + 1) % points.length];
    const p3 = points[(i + 2) % points.length];

    const cp1x = p1[0] + (p2[0] - p0[0]) * tension;
    const cp1y = p1[1] + (p2[1] - p0[1]) * tension;
    const cp2x = p2[0] - (p3[0] - p1[0]) * tension;
    const cp2y = p2[1] - (p3[1] - p1[1]) * tension;

    path += ` C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${p2[0]} ${p2[1]}`;
  }
  path += ' Z';
  return path;
}
function updateLabelLegend() {
  const container = document.getElementById('label-legend-items');
  container.innerHTML = ''; // clear previous

  const set = legendLabelSets[currentSet]; // current label set
  for (const id in set) {
    const div = document.createElement('div');
    div.style.display = 'flex';
    div.style.alignItems = 'center';
    div.style.marginBottom = '4px';

    if (currentSet=='Structures'){
      const nodeColor = cy.getElementById(id).style('background-color'); // optional color box
      const colorBox = document.createElement('div');
      colorBox.style.width = '16px';
      colorBox.style.height = '16px';
      colorBox.style.backgroundColor = nodeColor;
      colorBox.style.border = '1px solid rgba(0,0,0,0.2)';
      colorBox.style.marginRight = '6px';
      div.appendChild(colorBox);
    }
    const labelSpan = document.createElement('span');
    labelSpan.innerHTML = set[id]; // LaTeX code

    div.appendChild(labelSpan);
    container.appendChild(div);
  }

  // Trigger MathJax to render
  if (window.MathJax && MathJax.typesetPromise) {
    MathJax.typesetPromise().catch(err => console.warn('MathJax error:', err));
  }
}

// Call it initially and when switching label sets
updateLabelLegend();

function drawRegions() {
  syncSVGSize();
  regionsSVG.innerHTML = '';

  regionDefs.forEach(r => {
    const inflate = 0; // how much to push vertices outward
    const points = r.nodes.map(id => {
      const n = cy.getElementById(id);
      const pos = n.renderedPosition();
      return [pos.x, pos.y];
    });

    // Compute centroid
    const centroid = [
      points.reduce((sum, p) => sum + p[0], 0) / points.length,
      points.reduce((sum, p) => sum + p[1], 0) / points.length
    ];

    // Inflate polygon by moving vertices away from centroid
    const inflatedPoints = points.map(p => {
      const dx = p[0] - centroid[0];
      const dy = p[1] - centroid[1];
      const len = Math.sqrt(dx*dx + dy*dy);
      if(len === 0) return p; // avoid divide by zero
      const factor = (len + inflate) / len;
      return [centroid[0] + dx * factor, centroid[1] + dy * factor];
    });

    const poly = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
    poly.setAttribute('points', inflatedPoints.map(p => p.join(',')).join(' '));
    poly.setAttribute('fill', r.color);
    poly.setAttribute('stroke', r.border);
    poly.setAttribute('stroke-width', '1');
    poly.setAttribute('vector-effect','non-scaling-stroke');
    poly.setAttribute('stroke-linejoin','round'); // smooth corners
    regionsSVG.appendChild(poly);
  });

  regionsSVG.style.display = regionsVisible ? 'block' : 'none';
}



cy.on('render', () => {
  drawRegions();
  updateLabelPositions();
});

    // initial draw
    drawRegions();

    // keep in sync when window resized
    window.addEventListener('resize', () => {
      drawRegions();
      updateLabelPositions();
    });

    // --------------------------
    // Controls: label + region toggles + coloring
    // --------------------------
    function toggleLabels() {
      currentSet = (currentSet === 'Structures') ? 'Clones' : 'Structures';
      for (const id in labels) {
        labels[id].innerHTML = labelSets[currentSet][id] || id;
      }
      const btn = document.getElementById('btnToggleLabels');
      btn.textContent = currentSet === 'Structures' ? 'Switch to Clones' : 'Switch to Structures';
      // request re-typeset
      if (window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise();
      updateLabelLegend();

    }

    function toggleRegions() {
      regionsVisible = !regionsVisible;
      regionsSVG.style.display = regionsVisible ? 'block' : 'none';

      const btn = document.getElementById('btnToggleRegions');
      btn.textContent = regionsVisible ? 'Hide Complexity Classes' : 'Show Complexity Classes';

      // Show or hide the regions legend
      const regionLegend = document.getElementById('region-legend');
      if (regionLegend) {
        regionLegend.style.display = regionsVisible ? 'block' : 'none';
      }

    }

    const defaultColor = '#0074D9'; // original node color

function applyColorSet(setName) {
  const greenSets = {
    majority: new Set(['C1', 'I2', 'C2','Cleq2','B2','Bleq']), 
    nu4: new Set(['C1', 'I2', 'C2','Cleq2','B2','B3','Bleq','Bleq3']),   
    nu5: new Set(['C1', 'I2', 'C2','Cleq2','B2','B3','B4','Bleq','Bleq3','Bleq4']),     
    maltsev: new Set(['C1', 'I2','C2','LIN']), 
    hm2: new Set(['C1', 'I2','C2','LIN','B2','B3','B4','Binf']),  
  };

  cy.batch(() => {
    cy.nodes().forEach(n => {
      if (n.hasClass('helper')) return; // skip helper nodes
      if (setName === 'none') {
        n.style('background-color', defaultColor);
      } else {
        n.style('background-color', greenSets[setName].has(n.id()) ? 'green' : 'red');
      }
    });
  });
  updateLabelLegend();
}

const colorsetLatex = {
  majority: "\\[m(x,x,y)=m(x,y,x)=m(y,x,x)=x\\]",
  nu4: "\\[m(x,x,x,y)=\\dots=m(y,x,x,x)=x\\]",
  nu5: "\\[m(x,x,x,x,y)=\\dots=m(y,x,x,x,x)=x\\]",
  maltsev: "\\[m(y,y,x)=x=m(x,y,y)\\]",
  hm2: "\\[ \\begin{aligned} \
x &= p_1(x,y,y) \\\\ \
p_1(x,x,y) &= p_2(x,y,y) \\\\ \
p_2(x,x,y) &= y \
\\end{aligned} \\]"
};

document.getElementById('colorSelect').addEventListener('change', e => {
  const setName = e.target.value;

  // Color nodes
  applyColorSet(setName);

  // Update colorset legend
  const legendDiv = document.getElementById('colorset-legend');
  const legendText = document.getElementById('colorset-legend-text');

  if (setName === 'none') {
    legendDiv.style.display = 'none';
    legendText.innerHTML = '';
  } else {
    legendDiv.style.display = 'block';
    legendText.innerHTML = colorsetLatex[setName] || '';
    if (window.MathJax && MathJax.typesetPromise) {
      MathJax.typesetPromise().catch(err => console.warn('MathJax error:', err));
    }
  }
});


// Wire the dropdown
document.getElementById('colorSelect').addEventListener('change', e => {
  applyColorSet(e.target.value);
});


    // Wire buttons with event listeners (safer than inline onclick)
    document.getElementById('btnToggleLabels').addEventListener('click', toggleLabels);
    document.getElementById('btnToggleRegions').addEventListener('click', toggleRegions);
    document.getElementById('btnColorSet1').addEventListener('click', colorSet1);
    document.getElementById('btnColorSet2').addEventListener('click', colorSet2);

    // final sync just in case
    setTimeout(() => { drawRegions(); updateLabelPositions(); }, 50);
  </script>
</body>
</html>
